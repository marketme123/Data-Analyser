### **1\. Project Overview**

**Project Name:** Balistro STN Automatic Data Analyzer

**Objective:** To create a web-based application that allows users to upload CSV/XLSX files, and then use a Gemini-powered AI to analyze, manipulate, and export the data using natural language commands.

**Core Problem:** Bridge the gap between natural language user requests and the technical operations required for data manipulation. The AI will translate user intent into a series of executable commands defined in a "RuleBook."

### **2\. System Architecture**

This project can be built entirely on the front-end, simplifying development and deployment.

* **Front-End:** A single-page application (SPA) built with HTML, CSS, and JavaScript. This will handle the user interface, data parsing, and interaction with the Gemini API.  
* **AI Integration:** The Gemini API will be called directly from the JavaScript front-end to interpret user commands and generate the sequence of operations.  
* **Data Handling:** Data from uploaded files will be processed and stored in-memory in the browser as a JavaScript array of objects.

### **3\. Core Features & Functionality**

**3.1. File & API Key Management**

* **File Uploader:** An input field to accept .csv and .xlsx files.  
* **API Key Input:** A secure text field for the user to enter their Gemini API key. This will be stored in the browser's local storage for the session.  
* **Model Selection:** A dropdown or text input to specify the Gemini model to be used (e.g., gemini-2.5-flash-preview-05-20).

**3.2. Data Display & Interaction**

* **Data Table:** A dynamic HTML table to display the contents of the uploaded file. It should be scrollable and handle large datasets gracefully.  
* **Command Input:** A text area where the user can type their data analysis requests in plain English.  
* **Execute Button:** A button to submit the user's command to the AI.  
* **Output/Log Console:** A dedicated area to show the sequence of commands generated by the AI and the results of their execution.  
* **Data Export:** A button to export the modified data back to a .csv file.

**3.3. AI-Powered Command Generation**

* **The "RuleBook":** This is the heart of the project. It's a conceptual guide that you will hard-code into the prompt you send to the Gemini API. It will define the available JavaScript functions.  
* **Prompt Engineering:** The JavaScript code will construct a detailed prompt for the Gemini API. This prompt will include:  
  * The "RuleBook" (the list of available functions and their descriptions).  
  * The headers of the user's data.  
  * The user's natural language command.  
  * A clear instruction to the AI to return a JSON array of commands.  
* **Command Execution Engine:** A JavaScript function that iterates through the array of commands returned by the AI and executes them sequentially.

### **4\. The "RuleBook" \- Function Definitions**

This is the set of JavaScript functions that the AI will be able to call. You will write these functions in your JS file.

| Function Name | Parameters | Description | Example AI Output |
| :---- | :---- | :---- | :---- |
| selectColumns | columnNames (Array of strings) | Creates a new view of the data with only the specified columns. | { "function": "selectColumns", "args": { "columnNames": \["Name", "Age"\] } } |
| filterRows | columnName (string), operator (string), value (any) | Filters the data based on a condition. Operators: \===, \!==, \>, \<, \>=, \<=, contains. | { "function": "filterRows", "args": { "columnName": "Age", "operator": "\>", "value": 30 } } |
| sortData | columnName (string), direction (string: 'asc' or 'desc') | Sorts the data by a specific column. | { "function": "sortData", "args": { "columnName": "Salary", "direction": "desc" } } |
| createColumn | newColumnName (string), expression (string) | Adds a new column. The expression is a string that can reference other columns (e.g., "row\['ColumnA'\] \+ row\['ColumnB'\]"). | { "function": "createColumn", "args": { "newColumnName": "Full Name", "expression": "row\['First Name'\] \+ ' ' \+ row\['Last Name'\]" } } |
| deleteColumn | columnName (string) | Removes a column from the data. | { "function": "deleteColumn", "args": { "columnName": "Redundant Column" } } |
| updateValue | columnToUpdate (string), newValue (any), filter (object) | Updates a value in a specific column where a filter condition is met. | { "function": "updateValue", "args": { "columnToUpdate": "Status", "newValue": "Active", "filter": { "columnName": "ID", "operator": "===", "value": 123 } } } |
| calculate | columnName (string), operation (string) | Performs a calculation on a column. Operations: sum, average, count, min, max. | { "function": "calculate", "args": { "columnName": "Sales", "operation": "sum" } } |
| groupBy | columnName (string), aggregation (object) | Groups data by a column and performs an aggregation. | { "function": "groupBy", "args": { "columnName": "Department", "aggregation": { "column": "Salary", "operation": "average" } } } |

### **5\. Development Roadmap**

**Phase 1: Core UI and File Handling (The Skeleton)**

1. **HTML Structure:** Create the main index.html file with all the necessary divs, inputs, and buttons.  
2. **CSS Styling:** Apply basic styling to make the application presentable and user-friendly.  
3. **File Reading:** Write the JavaScript to handle file uploads. Use a library like SheetJS (xlsx.full.min.js) to parse both CSV and XLSX files into a JavaScript array of objects.  
4. **Data Table Display:** Write the function to dynamically generate and display the parsed data in an HTML table.

**Phase 2: The "RuleBook" and Command Engine (The Brains)**

1. **Implement RuleBook Functions:** Create a rulebook.js file and write all the JavaScript functions defined in the table above. Each function will take the current dataset as an input and return the modified dataset.  
2. **Command Executor:** Create the main execution engine that takes an array of command objects and runs them in sequence, passing the output of one command as the input to the next.

**Phase 3: Gemini API Integration (The AI Connection)**

1. **API Call Function:** Write a JavaScript function to make a fetch call to the Gemini API.  
2. **Prompt Construction:** Write the logic to dynamically build the detailed prompt that will be sent to the AI, including the RuleBook, data headers, and user query.  
3. **Response Handling:** Parse the JSON response from the API and feed the resulting command array into your command execution engine.  
4. **Error Handling:** Implement robust error handling for API calls and command execution.

**Phase 4: Final Touches & Deployment**

1. **Data Export:** Implement the "Export to CSV" functionality.  
2. **UI/UX Refinements:** Add loading indicators, user feedback messages, and improve the overall user experience.  
3. **Testing:** Thoroughly test the application with various datasets and commands.  
4. **Deployment:** Since this is a front-end-only application, you can easily deploy it using services like GitHub Pages, Netlify, or Vercel.

### **6\. File Structure**

/Balistro-Data-Analyzer  
|-- index.html  
|-- /css  
|   |-- style.css  
|-- /js  
|   |-- main.js         // Main application logic, event listeners  
|   |-- fileHandler.js  // Logic for reading and parsing files  
|   |-- rulebook.js     // All the data manipulation functions  
|   |-- gemini.js       // Logic for interacting with the Gemini API  
|-- /lib  
|   |-- xlsx.full.min.js // SheetJS library for file parsing  
